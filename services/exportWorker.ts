import jsPDF from 'jspdf';
import { RankedArticle, ResearchInput, AggregatedArticle, ResearchReport, Settings, CSV_EXPORT_COLUMNS, KnowledgeBaseEntry } from '../types';

// --- PDF Generation State & Helpers ---

const APP_NAME = 'AI Research Orchestrator';
const MARGIN = 15;
let doc: jsPDF;
let pageHeight: number;
let pageWidth: number;
let currentY: number;
let pageNumber: number;
let tocEntries: { title: string; page: number }[] = [];
let reportTitleForHeader: string | null = null;
let pdfSettings: Settings['export']['pdf'];


const cleanText = (text: string | undefined | null): string => {
    if (!text) return '';
    // Basic cleaning for jsPDF compatibility
    return text
        .replace(/<[^>]*>/g, "") // Remove HTML tags
        .replace(/[\u2018\u2019]/g, "'") // Replace smart single quotes
        .replace(/[\u201C\u201D]/g, '"') // Replace smart double quotes
        .replace(/[\u2013\u2014]/g, '-') // Replace en/em dashes
        .trim();
};


function initializePdf(title: string, settings: Settings['export']['pdf']) {
    doc = new jsPDF({ unit: 'mm', format: 'a4' });
    pageHeight = doc.internal.pageSize.getHeight();
    pageWidth = doc.internal.pageSize.getWidth();
    currentY = MARGIN;
    pageNumber = 1;
    tocEntries = [];
    reportTitleForHeader = title;
    pdfSettings = settings;

    // Add metadata
    doc.setProperties({
        title: cleanText(title),
        subject: 'AI-Generated Literature Review',
        author: APP_NAME,
        creator: APP_NAME,
    });
}

function addHeader() {
    if (!pdfSettings.includeHeader || !reportTitleForHeader) return;
    
    doc.setFontSize(8).setFont('helvetica', 'italic').setTextColor('#888888');
    const headerText = reportTitleForHeader.length > 90 
        ? reportTitleForHeader.substring(0, 87) + '...' 
        : reportTitleForHeader;
        
    doc.text(headerText, MARGIN, 10);
    doc.setDrawColor('#dddddd').line(MARGIN, 12, pageWidth - MARGIN, 12);
}

function addFooter() {
    if (!pdfSettings.includeFooter) return;
    
    doc.setFontSize(8).setFont('helvetica', 'italic').setTextColor('#888888');
    const footerText = `Page ${pageNumber} | Generated by ${APP_NAME}`;
    doc.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
}

function addPage() {
    if (pageNumber > 1) addFooter(); // Add footer to the outgoing page
    doc.addPage();
    pageNumber++;
    currentY = MARGIN;
    addHeader();
}

function checkPageBreak(spaceNeeded: number) {
    if (currentY + spaceNeeded > pageHeight - MARGIN) {
        addPage();
    }
}

function addSectionTitle(title: string, options: { addToToc?: boolean, skipTopMargin?: boolean } = {}) {
    const { addToToc = false, skipTopMargin = false } = options;
    if (addToToc) {
        tocEntries.push({ title: title, page: pageNumber });
    }
    checkPageBreak(skipTopMargin ? 15 : 25);
    if (!skipTopMargin) currentY += 5;
    
    doc.setFontSize(14).setFont('helvetica', 'bold').setTextColor('#1f6feb'); // Brand color
    doc.text(title, MARGIN, currentY);
    doc.setDrawColor('#1f6feb').setLineWidth(0.5).line(MARGIN, currentY + 2, MARGIN + 20, currentY + 2);
    currentY += 10;
}

function addBodyText(text: string) {
    const lines = doc.splitTextToSize(cleanText(text), pageWidth - MARGIN * 2);
    for (const line of lines) {
        checkPageBreak(5);
        doc.setFontSize(10).setFont('helvetica', 'normal').setTextColor('#333333');
        doc.text(line, MARGIN, currentY);
        currentY += 5;
    }
    currentY += 5;
}

function addKeyValue(key: string, value: string, options: { link?: string } = {}) {
    if (!value) return;

    const keyWidth = doc.getTextWidth(key) + 2;
    const valueMaxWidth = pageWidth - MARGIN * 2 - keyWidth - 5;
    const valueLines = doc.splitTextToSize(cleanText(value), valueMaxWidth);
    
    checkPageBreak(valueLines.length * 4 + 4);
    
    doc.setFontSize(9).setFont('helvetica', 'bold').setTextColor('#000000');
    doc.text(key, MARGIN + 5, currentY);

    doc.setFont('helvetica', 'normal').setTextColor('#555555');
    
    if (options.link) {
      doc.setTextColor('#1f6feb').textWithLink(valueLines[0], MARGIN + 5 + keyWidth, currentY, { url: options.link });
      if (valueLines.length > 1) {
          doc.text(valueLines.slice(1), MARGIN + 5 + keyWidth, currentY + 4);
      }
    } else {
      doc.text(valueLines, MARGIN + 5 + keyWidth, currentY);
    }

    currentY += valueLines.length * 4 + 2;
}

function addArticleEntry(article: AggregatedArticle, index: number) {
    const articleLink = article.pmcId 
      ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${article.pmcId}/`
      : `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/`;

    checkPageBreak(50); // Estimate space for an article entry
    currentY += 8;
    doc.setDrawColor('#e0e0e0').line(MARGIN, currentY - 4, pageWidth - MARGIN, currentY - 4);

    doc.setFontSize(12).setFont('helvetica', 'bold').setTextColor('#1f6feb');
    const titleLines = doc.splitTextToSize(`${index + 1}. ${cleanText(article.title)}`, pageWidth - MARGIN * 2);
    doc.textWithLink(titleLines, MARGIN, currentY, { url: articleLink });
    currentY += titleLines.length * 5 + 2;

    addKeyValue('Authors:', `${article.authors} (${article.pubYear})`);
    addKeyValue('Journal:', article.journal);
    addKeyValue('PMID:', article.pmid + (article.pmcId ? ` / PMCID: ${article.pmcId}` : ''));
    addKeyValue('Relevance:', `${article.relevanceScore}/100 - ${article.relevanceExplanation}`);
    
    // Summary in two columns for readability
    const summaryText = cleanText(article.summary);
    if (summaryText) {
        checkPageBreak(10);
        doc.setFontSize(9).setFont('helvetica', 'bold').setTextColor('#000000');
        doc.text("Summary:", MARGIN + 5, currentY);
        currentY += 4;

        const columnWidth = (pageWidth - MARGIN * 2 - 5) / 2;
        const summaryLines = doc.splitTextToSize(summaryText, columnWidth);
        const midPoint = Math.ceil(summaryLines.length / 2);
        const col1 = summaryLines.slice(0, midPoint);
        const col2 = summaryLines.slice(midPoint);

        checkPageBreak(Math.max(col1.length, col2.length) * 4);
        doc.setFontSize(9).setFont('helvetica', 'normal').setTextColor('#555555');
        doc.text(col1, MARGIN, currentY);
        doc.text(col2, MARGIN + columnWidth + 5, currentY);
        currentY += Math.max(col1.length, col2.length) * 4 + 2;
    }

    if (article.keywords?.length > 0) addKeyValue('Keywords:', article.keywords.join(', '));
    if (article.customTags?.length > 0) addKeyValue('Custom Tags:', article.customTags.join(', '));
}

function addTableOfContents() {
    addSectionTitle('Table of Contents', { skipTopMargin: true });
    doc.setFontSize(10).setFont('helvetica', 'normal').setTextColor('#333333');
    
    tocEntries.forEach(entry => {
        checkPageBreak(5);
        const titleWidth = doc.getTextWidth(entry.title);
        const pageNumStr = String(entry.page);
        const dotsWidth = pageWidth - MARGIN * 2 - titleWidth - doc.getTextWidth(pageNumStr) - 2;
        const dots = '.'.repeat(Math.floor(dotsWidth / doc.getTextWidth('.')));
        
        doc.text(`${entry.title} ${dots} ${pageNumStr}`, MARGIN, currentY);
        currentY += 6;
    });
}

// --- Main Worker Logic ---

self.onmessage = (event: MessageEvent) => {
    const { type, payload } = event.data;

    try {
        switch (type) {
            case 'EXPORT_PDF_REPORT':
                generateReportPdf(payload.report, payload.input, payload.settings);
                break;
            case 'EXPORT_PDF_KB':
                generateKnowledgeBasePdf(payload.articles, payload.title, payload.findRelatedInsightsFn, payload.settings);
                break;
            case 'EXPORT_CSV':
                generateCsv(payload.articles, payload.topic, payload.settings);
                break;
            case 'EXPORT_INSIGHTS_CSV':
                generateInsightsCsv(payload.insights, payload.topic);
                break;
            case 'EXPORT_CITATIONS':
                generateCitations(payload.articles, payload.format, payload.settings);
                break;
            case 'EXPORT_JSON_HISTORY':
                generateJson(payload.entries, 'history', payload.entries.length);
                break;
            case 'EXPORT_JSON_KB':
                generateJson(payload.articles, 'knowledge-base-articles', payload.articles.length);
                break;
            case 'EXPORT_JSON_COMPLETE':
                generateJson(payload.data, 'complete-backup', 1);
                break;
        }
    } catch (error) {
        console.error('Error in export worker:', error);
        self.postMessage({ type: 'ERROR', error: error instanceof Error ? error.message : 'An unknown error occurred in the export worker.' });
    }
};

// --- PDF Generation Functions ---

function generateReportPdf(report: ResearchReport, input: ResearchInput, settings: Settings['export']['pdf']) {
    initializePdf(input.researchTopic, settings);

    if (settings.includeCoverPage) {
        doc.setFontSize(22).setFont('helvetica', 'bold').text('AI Research Report', pageWidth / 2, 60, { align: 'center' });
        doc.setFontSize(14).setFont('helvetica', 'normal').text(input.researchTopic, pageWidth / 2, 75, { align: 'center', maxWidth: pageWidth - 60 });
        doc.setFontSize(10).setFont('helvetica', 'italic').setTextColor('#888888');
        doc.text(`Generated on ${new Date().toLocaleDateString()}`, pageWidth / 2, 95, { align: 'center' });
        if (settings.preparedFor) {
            doc.text(`Prepared for: ${settings.preparedFor}`, pageWidth / 2, 105, { align: 'center' });
        }
        
        doc.setFontSize(12).setFont('helvetica', 'bold').setTextColor('#000000');
        doc.text('Research Parameters', pageWidth / 2, 120, { align: 'center' });
        doc.setFontSize(10).setFont('helvetica', 'normal').setTextColor('#555555');
        const params = [
            `Date Range: ${input.dateRange === 'any' ? 'Any time' : `Last ${input.dateRange} years`}`,
            `Article Types: ${input.articleTypes.join(', ') || 'Any'}`,
            `Synthesis Focus: ${input.synthesisFocus}`,
            `Articles Scanned: ${input.maxArticlesToScan}`,
            `Articles Synthesized: ${input.topNToSynthesize}`
        ];
        doc.text(params.join('\n'), pageWidth / 2, 130, { align: 'center' });

        addPage();
    }
    
    // TOC Pass 1: Gather entries
    const tocPage = pageNumber;
    if (settings.includeToc) {
        if (settings.includeSynthesis) tocEntries.push({ title: 'Executive Synthesis', page: 0 });
        if (settings.includeInsights) tocEntries.push({ title: 'AI-Generated Insights', page: 0 });
        tocEntries.push({ title: `Ranked Articles (Top ${report.rankedArticles.length})`, page: 0 });
        if (settings.includeQueries) tocEntries.push({ title: 'Generated PubMed Queries', page: 0 });
        addPage();
    }

    // Content Pass
    if (settings.includeSynthesis) {
        const tocItem = tocEntries.find(e => e.title === 'Executive Synthesis');
        if (tocItem) tocItem.page = pageNumber;
        addSectionTitle('Executive Synthesis', { skipTopMargin: !settings.includeCoverPage && !settings.includeToc });
        addBodyText(report.synthesis);
    }
    
    if (settings.includeInsights) {
        const tocItem = tocEntries.find(e => e.title === 'AI-Generated Insights');
        if (tocItem) tocItem.page = pageNumber;
        addSectionTitle('AI-Generated Insights');
        report.aiGeneratedInsights.forEach(insight => {
            checkPageBreak(30);
            addKeyValue('Question:', insight.question);
            addKeyValue('Answer:', insight.answer);
            addKeyValue('Sources (PMID):', insight.supportingArticles.join(', '));
            currentY += 5;
        });
    }

    const tocItemArticles = tocEntries.find(e => e.title.startsWith('Ranked Articles'));
    if (tocItemArticles) tocItemArticles.page = pageNumber;
    addSectionTitle(`Ranked Articles (Top ${report.rankedArticles.length})`);
    report.rankedArticles.forEach((article, index) => {
        addArticleEntry({ ...article, sourceReportTopic: input.researchTopic }, index);
    });

    if (settings.includeQueries) {
        const tocItemQueries = tocEntries.find(e => e.title.startsWith('Generated PubMed Queries'));
        if (tocItemQueries) tocItemQueries.page = pageNumber;
        addSectionTitle('Generated PubMed Queries');
        report.generatedQueries.forEach(q => {
            checkPageBreak(25);
            addKeyValue('Query:', q.query);
            addKeyValue('Explanation:', q.explanation);
            currentY += 5;
        });
    }
    
    // TOC Pass 2: Render TOC
    if (settings.includeToc) {
        const currentPage = pageNumber;
        const currentYBackup = currentY;
        doc.setPage(tocPage);
        currentY = MARGIN;
        addTableOfContents();
        doc.setPage(currentPage);
        currentY = currentYBackup;
    }

    addFooter(); // Add footer to the very last page
    const pdfBlob = doc.output('blob');
    self.postMessage({ type: 'SUCCESS', blob: pdfBlob, filename: `report_${input.researchTopic.substring(0, 20).replace(/\s/g, '_')}.pdf` });
}

function generateKnowledgeBasePdf(articles: AggregatedArticle[], title: string, findRelatedInsightsFnStr: string, settings: Settings['export']['pdf']) {
    const findRelatedInsights = new Function(`return ${findRelatedInsightsFnStr}`)();
    initializePdf(title, settings);

     if (settings.includeCoverPage) {
        doc.setFontSize(22).setFont('helvetica', 'bold').text('Knowledge Base Export', pageWidth / 2, 80, { align: 'center' });
        doc.setFontSize(14).setFont('helvetica', 'normal').text(title, pageWidth / 2, 95, { align: 'center', maxWidth: pageWidth - 60 });
        doc.setFontSize(10).setFont('helvetica', 'italic').setTextColor('#888888');
        doc.text(`Exported ${articles.length} articles on ${new Date().toLocaleDateString()}`, pageWidth / 2, 110, { align: 'center' });
        if(settings.preparedFor) {
            doc.text(`Prepared for: ${settings.preparedFor}`, pageWidth / 2, 120, { align: 'center' });
        }
        addPage();
    }

    addSectionTitle('Exported Articles');
    articles.forEach((article, index) => {
        addArticleEntry(article, index);
        const insights = findRelatedInsights(article.pmid);
        if (settings.includeInsights && insights.length > 0) {
            addKeyValue('Related Insights:', `${insights.length} insight(s) linked to this article.`);
        }
    });

    addFooter();
    const pdfBlob = doc.output('blob');
    self.postMessage({ type: 'SUCCESS', blob: pdfBlob, filename: `knowledge_base_${title.replace(/\s/g, '_')}.pdf` });
}


// --- Other Export Functions ---

function generateCsv(articlesToExport: AggregatedArticle[], topic: string, settings: Settings['export']['csv']) {
    const escapeCsvField = (field: any): string => {
        if (field === null || field === undefined) return '';
        let str = String(field);
        if (str.includes(settings.delimiter) || str.includes('"') || str.includes('\n')) {
            str = `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    };

    const headers = settings.columns;
    const rows = articlesToExport.map(article => {
        const articleUrl = `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/`;
        const pmcidUrl = article.pmcId ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${article.pmcId}/` : '';
        const googleScholarUrl = `https://scholar.google.com/scholar?q=${encodeURIComponent(article.title)}`;
        const semanticScholarUrl = `https://www.semanticscholar.org/search?q=${encodeURIComponent(article.title)}`;
        
        const rowData: Record<(typeof CSV_EXPORT_COLUMNS)[number], any> = {
            ...article,
            pmcId: article.pmcId ?? '',
            keywords: article.keywords.join('; '),
            customTags: article.customTags?.join('; ') || '',
            sourceReportTopic: article.sourceReportTopic || topic,
            articleType: article.articleType || 'N/A',
            URL: articleUrl,
            PMCID_URL: pmcidUrl,
            GOOGLE_SCHOLAR_URL: googleScholarUrl,
            SEMANTIC_SCHOLAR_URL: semanticScholarUrl,
        };
        return headers.map(header => escapeCsvField(rowData[header])).join(settings.delimiter);
    });

    const csvContent = [headers.join(settings.delimiter), ...rows].join('\n');
    const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
    self.postMessage({ type: 'SUCCESS', blob, filename: `report_${topic.substring(0, 20).replace(/\s/g, '_')}.csv` });
}

function generateInsightsCsv(insights: ResearchReport['aiGeneratedInsights'], topic: string) {
    const escapeCsvField = (field: any): string => {
        if (field === null || field === undefined) return '';
        let str = String(field);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) str = `"${str.replace(/"/g, '""')}"`;
        return str;
    };

    const headers = ['ReportTopic', 'Question', 'Answer', 'Supporting PMIDs'];
    const rows = insights.map(insight => [
        topic,
        insight.question,
        insight.answer,
        insight.supportingArticles.join('; ')
    ].map(escapeCsvField).join(','));

    const csvContent = [headers.join(','), ...rows].join('\n');
    const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
    self.postMessage({ type: 'SUCCESS', blob, filename: `ai_insights_${topic.substring(0, 20).replace(/\s/g, '_')}.csv` });
}


function generateCitations(articles: AggregatedArticle[], format: 'bib' | 'ris', settings: Settings['export']['citation']) {
    let content = '';
    const cleanForBibtex = (text: string) => text.replace(/([{}%#&\\])/g, '\\$1');

    if (format === 'bib') {
        content = articles.map(a => {
            const articleLink = a.pmcId 
                ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${a.pmcId}/`
                : `https://pubmed.ncbi.nlm.nih.gov/${a.pmid}/`;

            let entry = `@article{PMID:${a.pmid},\n  author  = {${a.authors.split(', ').map(cleanForBibtex).join(' and ')}},\n  title   = {${cleanForBibtex(a.title)}},\n  journal = {${cleanForBibtex(a.journal)}},\n  year    = {${a.pubYear}},\n  pmid    = {${a.pmid}},\n  url     = {${articleLink}},\n`;
            if (settings.includeAbstract) entry += `  abstract = {${cleanForBibtex(a.summary)}},\n`;
            if (settings.includeKeywords && a.keywords?.length > 0) entry += `  keywords = {${cleanForBibtex(a.keywords.join(', '))}},\n`;
            
            const notes = [];
            if (settings.includeTags && a.customTags?.length > 0) notes.push(`Custom Tags: ${a.customTags.join(', ')}`);
            if (settings.includePmcid && a.pmcId) notes.push(`PMCID: ${a.pmcId}`);
            if (notes.length > 0) entry += `  note = {${cleanForBibtex(notes.join('; '))}}\n`;
            
            entry += `}`;
            return entry;
        }).join('\n\n');
    } else { // RIS
        content = articles.map(a => {
             const articleLink = a.pmcId 
                ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${a.pmcId}/`
                : `https://pubmed.ncbi.nlm.nih.gov/${a.pmid}/`;
            let entry = `TY  - JOUR\n`;
            entry += a.authors.split(', ').map(author => `AU  - ${author}`).join('\n') + '\n';
            entry += `TI  - ${a.title}\nJO  - ${a.journal}\nYR  - ${a.pubYear}\n`;
            if (settings.includeAbstract) entry += `AB  - ${a.summary}\n`;
            if (settings.includeKeywords && a.keywords?.length > 0) entry += `${a.keywords.map(kw => `KW  - ${kw}`).join('\n')}\n`;
            if (settings.includeTags && a.customTags?.length > 0) entry += `${a.customTags.map(tag => `KW  - ${tag}`).join('\n')}\n`;
            entry += `UR  - ${articleLink}\n`;
            entry += `M1  - ${a.pmid}\n`; // M1 for PubMed ID
            if (settings.includePmcid && a.pmcId) entry += `N1  - PMCID: ${a.pmcId}\n`;
            entry += 'ER  - \n';
            return entry;
        }).join('\n');
    }

    const blob = new Blob([content], { type: 'application/octet-stream' });
    self.postMessage({ type: 'SUCCESS', blob, filename: `citations.${format}` });
}

function generateJson(data: any, type: string, count: number) {
    const exportObject = {
        meta: {
            appName: APP_NAME,
            exportDate: new Date().toISOString(),
            type: type,
            schemaVersion: "1.1",
            count: count,
        },
        data: data
    };
    const jsonString = JSON.stringify(exportObject, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
    const date = new Date().toISOString().split('T')[0];
    self.postMessage({ type: 'SUCCESS', blob, filename: `ai_research_${type}_${date}.json` });
}
