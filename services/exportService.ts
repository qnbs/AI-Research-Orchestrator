import jsPDF from 'jspdf';
import { RankedArticle, ResearchInput, AggregatedArticle, ResearchReport, Settings, CSV_EXPORT_COLUMNS, KnowledgeBaseEntry } from '../types';

// --- PDF Generation Helpers ---

const APP_NAME = 'AI Research Orchestration Author';
const MARGIN = 15;
let doc: jsPDF;
let pageHeight: number;
let pageWidth: number;
let currentY: number;
let pageNumber: number;
let tocEntries: { title: string; page: number }[] = [];

const cleanText = (text: string) => text ? text.replace(/<[^>]*>/g, "").replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"') : '';

function initializePdf(title: string, settings: Settings['export']['pdf']) {
    doc = new jsPDF();
    pageHeight = doc.internal.pageSize.getHeight();
    pageWidth = doc.internal.pageSize.getWidth();
    currentY = MARGIN;
    pageNumber = 1;
    tocEntries = [];

    // Add metadata
    doc.setProperties({
        title: title,
        subject: 'AI-Generated Literature Review',
        author: APP_NAME,
        creator: APP_NAME,
    });
}

function addHeader(title: string) {
    doc.setFontSize(8).setFont('helvetica', 'italic').setTextColor(150);
    const headerText = title.length > 90 ? title.substring(0, 87) + '...' : title;
    doc.text(headerText, MARGIN, 10);
    doc.setDrawColor(200).line(MARGIN, 12, pageWidth - MARGIN, 12);
}

function addFooter() {
    doc.setFontSize(8).setFont('helvetica', 'italic').setTextColor(150);
    const footerText = `Page ${pageNumber} | Generated by ${APP_NAME}`;
    doc.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
}

function addPage(titleForHeader: string | null = null, settings: Settings['export']['pdf']) {
    if (settings.includeFooter) addFooter();
    doc.addPage();
    pageNumber++;
    currentY = MARGIN;
    if (settings.includeHeader && titleForHeader) addHeader(titleForHeader);
}

function checkPageBreak(spaceNeeded: number, titleForHeader: string | null = null, settings: Settings['export']['pdf']) {
    if (currentY + spaceNeeded > pageHeight - MARGIN) {
        addPage(titleForHeader, settings);
    }
}

function addSectionTitle(title: string, titleForHeader: string | null, settings: Settings['export']['pdf'], options: { addToToc?: boolean } = {}) {
    if (options.addToToc) {
        tocEntries.push({ title: title, page: pageNumber });
    }
    checkPageBreak(15, titleForHeader, settings);
    doc.setFontSize(14).setFont('helvetica', 'bold').setTextColor(0);
    doc.text(title, MARGIN, currentY);
    currentY += 8;
}

function addBodyText(text: string, titleForHeader: string | null = null, settings: Settings['export']['pdf']) {
    const lines = doc.splitTextToSize(cleanText(text), pageWidth - MARGIN * 2);
    for (const line of lines) {
        checkPageBreak(5, titleForHeader, settings);
        doc.setFontSize(10).setFont('helvetica', 'normal').setTextColor(80);
        doc.text(line, MARGIN, currentY);
        currentY += 5;
    }
    currentY += 5;
}


function addKeyValue(key: string, value: string, titleForHeader: string | null = null, settings: Settings['export']['pdf']) {
    if (!value) return;
    const valueLines = doc.splitTextToSize(cleanText(value), pageWidth - MARGIN * 2 - 40);
    checkPageBreak(valueLines.length * 4 + 4, titleForHeader, settings);
    doc.setFontSize(9).setFont('helvetica', 'bold').setTextColor(0);
    doc.text(key, MARGIN + 5, currentY);
    doc.setFont('helvetica', 'normal').setTextColor(80);
    doc.text(valueLines, MARGIN + 40, currentY);
    currentY += valueLines.length * 4 + 4;
}

function addTableOfContents(titleForHeader: string | null, settings: Settings['export']['pdf']) {
    addSectionTitle('Table of Contents', titleForHeader, settings);
    doc.setFontSize(10).setFont('helvetica', 'normal');
    let tocY = currentY;
    tocEntries.forEach(entry => {
        checkPageBreak(5, titleForHeader, settings); // Ensure space for each line
        const dots = '.'.repeat(Math.max(0, 80 - entry.title.length));
        doc.text(`${entry.title} ${dots} ${entry.page}`, MARGIN, tocY);
        tocY += 5;
    });
    currentY = tocY + 5;
}

// --- Export Functions ---

export const exportToPdf = (report: ResearchReport, input: ResearchInput, settings: Settings['export']['pdf']): void => {
    initializePdf(input.researchTopic, settings);

    // Cover Page
    if (settings.includeCoverPage) {
        doc.setFontSize(22).setFont('helvetica', 'bold').text('AI Research Report', pageWidth / 2, 60, { align: 'center' });
        doc.setFontSize(14).setFont('helvetica', 'normal').text(input.researchTopic, pageWidth / 2, 75, { align: 'center', maxWidth: pageWidth - 60 });
        doc.setFontSize(10).setFont('helvetica', 'italic').setTextColor(150);
        doc.text(`Generated on ${new Date().toLocaleDateString()}`, pageWidth / 2, 95, { align: 'center' });
        if(settings.preparedFor) {
            doc.text(`Prepared for: ${settings.preparedFor}`, pageWidth / 2, 105, { align: 'center' });
        }
        
        doc.setFontSize(12).setFont('helvetica', 'bold').setTextColor(0);
        doc.text('Research Parameters', pageWidth / 2, 120, { align: 'center' });
        doc.setFontSize(10).setFont('helvetica', 'normal').setTextColor(80);
        const params = [
            `Date Range: Last ${input.dateRange} years`,
            `Article Types: ${input.articleTypes.join(', ') || 'Any'}`,
            `Synthesis Focus: ${input.synthesisFocus}`,
            `Articles Scanned: ${input.maxArticlesToScan}`,
            `Articles Synthesized: ${input.topNToSynthesize}`
        ];
        doc.text(params.join('\n'), pageWidth / 2, 130, { align: 'center' });

        addPage(input.researchTopic, settings);
    }
    
    // Build TOC entries before rendering sections
    if(settings.includeToc) {
        if (settings.includeSynthesis) tocEntries.push({ title: 'Executive Synthesis', page: pageNumber });
        if (settings.includeInsights) tocEntries.push({ title: 'AI-Generated Insights', page: pageNumber });
        tocEntries.push({ title: `Ranked Articles (Top ${report.rankedArticles.length})`, page: -1 }); // Page number will be updated later
        if (settings.includeQueries) tocEntries.push({ title: 'Generated PubMed Queries', page: -1 });
        addTableOfContents(input.researchTopic, settings);
        addPage(input.researchTopic, settings);
    }
    
    if (settings.includeSynthesis) {
        addSectionTitle('Executive Synthesis', input.researchTopic, settings);
        addBodyText(report.synthesis, input.researchTopic, settings);
    }
    
    if (settings.includeInsights) {
        addSectionTitle('AI-Generated Insights', input.researchTopic, settings);
        report.aiGeneratedInsights.forEach(insight => {
            checkPageBreak(25, input.researchTopic, settings);
            addKeyValue('Question:', insight.question, input.researchTopic, settings);
            addKeyValue('Answer:', insight.answer, input.researchTopic, settings);
            addKeyValue('Sources (PMID):', insight.supportingArticles.join(', '), input.researchTopic, settings);
            currentY += 5;
        });
    }

    const rankedArticlesTocIndex = tocEntries.findIndex(e => e.title.startsWith('Ranked Articles'));
    if (rankedArticlesTocIndex !== -1) tocEntries[rankedArticlesTocIndex].page = pageNumber;
    addSectionTitle(`Ranked Articles (Top ${report.rankedArticles.length})`, input.researchTopic, settings);
    report.rankedArticles.forEach((article, index) => {
        const articleLink = article.pmcId ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${article.pmcId}/` : `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/`;

        checkPageBreak(60, input.researchTopic, settings);
        doc.setFontSize(12).setFont('helvetica', 'bold').setTextColor(41, 128, 185);
        doc.textWithLink(`${index + 1}. ${cleanText(article.title)}`, MARGIN, currentY, { url: articleLink });
        currentY += 7;

        addKeyValue('Authors:', `${article.authors} (${article.pubYear})`, input.researchTopic, settings);
        addKeyValue('Journal:', article.journal, input.researchTopic, settings);
        addKeyValue('PMID:', article.pmid + (article.pmcId ? ` / PMCID: ${article.pmcId}` : ''), input.researchTopic, settings);
        addKeyValue('Relevance:', `${article.relevanceScore}/100 - ${article.relevanceExplanation}`, input.researchTopic, settings);
        addKeyValue('Summary:', article.summary, input.researchTopic, settings);
        addKeyValue('Keywords:', (article.keywords || []).join(', '), input.researchTopic, settings);
        if (article.customTags && article.customTags.length > 0) {
            addKeyValue('Custom Tags:', article.customTags.join(', '), input.researchTopic, settings);
        }
        currentY += 10;
    });

    if (settings.includeQueries) {
        const queriesTocIndex = tocEntries.findIndex(e => e.title.startsWith('Generated PubMed Queries'));
        if (queriesTocIndex !== -1) tocEntries[queriesTocIndex].page = pageNumber;
        addSectionTitle('Generated PubMed Queries', input.researchTopic, settings);
        report.generatedQueries.forEach(q => {
            checkPageBreak(20, input.researchTopic, settings);
            addKeyValue('Query:', q.query, input.researchTopic, settings);
            addKeyValue('Explanation:', q.explanation, input.researchTopic, settings);
            currentY += 5;
        });
    }
    
    // Go back and render the TOC with correct page numbers
    if (settings.includeToc) {
        doc.setPage(settings.includeCoverPage ? 2 : 1);
        currentY = MARGIN; // Reset Y for the TOC page
        addTableOfContents(input.researchTopic, settings);
    }


    // Finalize: Add footer to all pages
    if(settings.includeFooter) {
        for (let i = 1; i <= pageNumber; i++) {
            doc.setPage(i);
            addFooter();
        }
    }
    doc.save(`report_${input.researchTopic.substring(0, 20).replace(/\s/g, '_')}.pdf`);
};

export const exportKnowledgeBaseToPdf = (
    articlesToExport: AggregatedArticle[], 
    title: string,
    findRelatedInsights: (pmid: string) => { question: string, answer: string, supportingArticles: string[] }[],
    settings: Settings['export']['pdf']
): void => {
    initializePdf(title, settings);

    // Cover Page
    if (settings.includeCoverPage) {
        doc.setFontSize(22).setFont('helvetica', 'bold').text('Knowledge Base Export', pageWidth / 2, 80, { align: 'center' });
        doc.setFontSize(14).setFont('helvetica', 'normal').text(title, pageWidth / 2, 95, { align: 'center', maxWidth: pageWidth - 60 });
        doc.setFontSize(10).setFont('helvetica', 'italic').setTextColor(150);
        doc.text(`Exported ${articlesToExport.length} articles on ${new Date().toLocaleDateString()}`, pageWidth / 2, 110, { align: 'center' });
        if(settings.preparedFor) {
            doc.text(`Prepared for: ${settings.preparedFor}`, pageWidth / 2, 120, { align: 'center' });
        }
        addPage(title, settings);
    }

    addSectionTitle('Exported Articles', title, settings);
    articlesToExport.forEach((article, index) => {
        const articleLink = article.pmcId ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${article.pmcId}/` : `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/`;

        checkPageBreak(60, title, settings);
        doc.setFontSize(12).setFont('helvetica', 'bold').setTextColor(41, 128, 185);
        doc.textWithLink(`${index + 1}. ${cleanText(article.title)}`, MARGIN, currentY, { url: articleLink });
        currentY += 7;

        addKeyValue('Authors:', `${article.authors} (${article.pubYear})`, title, settings);
        addKeyValue('Journal:', article.journal, title, settings);
        addKeyValue('PMID:', article.pmid + (article.pmcId ? ` / PMCID: ${article.pmcId}` : ''), title, settings);
        addKeyValue('Relevance:', `${article.relevanceScore}/100 - ${article.relevanceExplanation}`, title, settings);
        addKeyValue('Summary:', article.summary, title, settings);
        addKeyValue('Keywords:', (article.keywords || []).join(', '), title, settings);
         if (article.customTags && article.customTags.length > 0) {
            addKeyValue('Custom Tags:', article.customTags.join(', '), title, settings);
        }
        
        const insights = findRelatedInsights(article.pmid);
        if (settings.includeInsights && insights.length > 0) {
            checkPageBreak(10, title, settings);
            addKeyValue('Related Insights:', `${insights.length} insight(s) linked to this article.`, title, settings);
        }

        currentY += 10;
        if(index < articlesToExport.length - 1) {
            checkPageBreak(10, title, settings);
            doc.setDrawColor(200).line(MARGIN, currentY, pageWidth - MARGIN, currentY);
            currentY += 10;
        }
    });

    if(settings.includeFooter) {
        for (let i = 1; i <= pageNumber; i++) {
            doc.setPage(i);
            addFooter();
        }
    }
    doc.save(`knowledge_base_export_${title.substring(0, 20).replace(/\s/g, '_')}.pdf`);
};

export const exportToCsv = (articlesToExport: AggregatedArticle[], topic: string, settings: Settings['export']['csv']): void => {
    const escapeCsvField = (field: any): string => {
        if (field === null || field === undefined) return '';
        let str = String(field);
        if (str.includes(settings.delimiter) || str.includes('"') || str.includes('\n')) str = `"${str.replace(/"/g, '""')}"`;
        return str;
    };

    const headers = settings.columns;
    const rows = articlesToExport.map(article => {
        const articleUrl = `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/`;
        const pmcidUrl = article.pmcId ? `https://www.ncbi.nlm.nih.gov/pmc/articles/${article.pmcId}/` : '';
        
        // Fix: Ensure all optional properties have a default value to match the Record type.
        // Fix: Changed 'sourceReportTopic' to 'sourceTitle' to match the AggregatedArticle type.
        const rowData: Record<(typeof CSV_EXPORT_COLUMNS)[number], any> = {
            ...article,
            aiSummary: article.aiSummary ?? '',
            pmcId: article.pmcId ?? '',
            keywords: (article.keywords || []).join('; '),
            customTags: article.customTags?.join('; ') || '',
            sourceTitle: article.sourceTitle || topic,
            articleType: article.articleType || 'N/A',
            URL: articleUrl,
            PMCID_URL: pmcidUrl
        };

        return headers.map(header => escapeCsvField(rowData[header])).join(settings.delimiter);
    });

    const csvContent = [headers.join(settings.delimiter), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `report_export_${topic.substring(0, 20).replace(/\s/g, '_')}.csv`;
    link.click();
    URL.revokeObjectURL(link.href);
};

export const exportInsightsToCsv = (insights: ResearchReport['aiGeneratedInsights'], topic: string): void => {
    const escapeCsvField = (field: any): string => {
        if (field === null || field === undefined) return '';
        let str = String(field);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            str = `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    };

    const headers = ['ReportTopic', 'Question', 'Answer', 'Supporting PMIDs'];
    const rows = insights.map(insight => [
        topic,
        insight.question,
        insight.answer,
        (insight.supportingArticles || []).join('; ')
    ].map(escapeCsvField).join(','));

    const csvContent = [headers.join(','), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `ai_insights_${topic.substring(0, 20).replace(/\s/g, '_')}.csv`;
    link.click();
    URL.revokeObjectURL(link.href);
};


// --- JSON Export with Metadata ---

const createJsonExport = (data: any, type: string, count: number) => {
    const exportObject = {
        meta: {
            appName: APP_NAME,
            exportDate: new Date().toISOString(),
            type: type,
            count: count,
        },
        data: data
    };
    const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(exportObject, null, 2))}`;
    const link = document.createElement("a");
    link.href = jsonString;
    const date = new Date().toISOString().split('T')[0];
    link.download = `ai_research_orchestration_author_${type}_${date}.json`;
    link.click();
};

export const exportHistoryToJson = (entries: KnowledgeBaseEntry[]): void => {
    createJsonExport(entries, 'history', entries.length);
};

export const exportKnowledgeBaseToJson = (articles: AggregatedArticle[]): void => {
    createJsonExport(articles, 'knowledge-base-articles', articles.length);
};

export const exportCitations = (articles: AggregatedArticle[], settings: Settings['export']['citation'], type: 'bib' | 'ris'): void => {
    let content = '';

    const cleanForBibtex = (text: string) => {
        if (!text) return '{}';
        // More comprehensive BibTeX escaping
        let s = text.replace(/\\/g, '\\textbackslash{}');
        s = s.replace(/([&%$#_{}])/g, '\\$1');
        s = s.replace(/~/g, '\\textasciitilde{}');
        s = s.replace(/\^/g, '\\textasciicircum{}');
        return `{${s}}`;
    };

    const cleanForRis = (text: string) => {
        if (!text) return '';
        // RIS format is line-based. Newlines in content are a problem.
        return cleanText(text).replace(/(\r\n|\n|\r)/gm, " ").replace(/\s\s+/g, ' ').trim();
    }


    if (type === 'bib') {
        content = articles.map(a => {
            let entry = `@article{PMID:${a.pmid},\n  author  = {${a.authors.split(', ').join(' and ')}},\n  title   = ${cleanForBibtex(a.title)},\n  journal = ${cleanForBibtex(a.journal)},\n  year    = {${a.pubYear}},\n  pmid    = {${a.pmid}},\n`;
            if (settings.includeAbstract) entry += `  abstract = ${cleanForBibtex(a.summary)},\n`;
            if (settings.includeKeywords && a.keywords?.length > 0) entry += `  keywords = {${a.keywords.join(', ')}},\n`;
            
            const notes = [];
            if (settings.includeTags && a.customTags?.length > 0) notes.push(`Custom Tags: ${a.customTags.join(', ')}`);
            if (settings.includePmcid && a.pmcId) notes.push(`PMCID: ${a.pmcId}`);
            if (notes.length > 0) entry += `  note = ${cleanForBibtex(notes.join('; '))}\n`;
            
            entry += `}`;
            return entry;
        }).join('\n\n');
    } else { // RIS
        content = articles.map(a => {
            let entry = `TY  - JOUR\n`;
            entry += a.authors.split(', ').map(author => `AU  - ${author}`).join('\n') + '\n';
            entry += `TI  - ${cleanForRis(a.title)}\nJO  - ${cleanForRis(a.journal)}\nYR  - ${a.pubYear}\n`;
            if (settings.includeAbstract) entry += `AB  - ${cleanForRis(a.summary)}\n`;
            if (settings.includeKeywords && a.keywords?.length > 0) entry += `${a.keywords.map(kw => `KW  - ${cleanForRis(kw)}`).join('\n')}\n`;
            if (settings.includeTags && a.customTags?.length > 0) entry += `${a.customTags.map(tag => `KW  - ${cleanForRis(tag)}`).join('\n')}\n`; // Using KW for custom tags too
            entry += `ID  - ${a.pmid}\n`;
            if (settings.includePmcid && a.pmcId) entry += `N1  - PMCID: ${a.pmcId}\n`; // N1 is often used for notes
            entry += 'ER  - \n';
            return entry;
        }).join('\n');
    }
    const blob = new Blob([content], { type: 'application/octet-stream;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `citations.${type}`;
    link.click();
    URL.revokeObjectURL(link.href);
};